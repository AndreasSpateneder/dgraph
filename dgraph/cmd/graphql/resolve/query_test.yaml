-
  name: "ID query"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : name
      }
    }

-
  name: "ID query with query alias"
  gqlquery: |
    query {
      author : getAuthor(id: "0x1") {
        name
      }
    }
  dgquery: |-
    query {
      author(func: uid(0x1)) @filter(type(Author)) {
        name : name
      }
    }

-
  name: "ID query with field alias"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        authName : name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        authName : name
      }
    }

-
  name: "ID field gets transformed to uid"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        id
        name
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        id : uid
        name : name
      }
    }

-
  name: "ID query with depth"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        posts {
          title
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : name
        posts : posts {
          title : title
          text : text
        }
      }
    }

-
  name: "ID query with depth and alias"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        allPosts : posts {
          postTitle : title
          postText : text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : name
        allPosts : posts {
          postTitle : title
          postText : text
        }
      }
    }

-
  name: "ID query deep"
  gqlquery: |
    query {
      getAuthor(id: "0x1") {
        name
        allPosts : posts {
          title
          text
          author {
            authorID : id
            name
          }
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : name
        allPosts : posts {
          title : title
          text : text
          author : author {
            authorID : uid
            name : name
          }
        }
      }
    }

-
  name: "Query with no args is query for everything of that type"
  gqlquery: |
    query {
      queryAuthor {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
      }
    }

-
  name: "Filter gets rewritten as @filter"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "Filters in same input object implies AND"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, dob: { le: "2001-01-01" }, reputation: { gt: 2.5 } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((le(dob, "2001-01-01") AND eq(name, "A. N. Author") AND gt(reputation, 2.5))) {
        name : name
      }
    }

-
  name: "Filter with nested 'and'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, and: { dob: { le: "2001-01-01" }, and: { reputation: { gt: 2.5 } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((gt(reputation, 2.5) AND le(dob, "2001-01-01")) AND eq(name, "A. N. Author"))) {
        name : name
      }
    }

-
  name: "Filter with 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(name, "A. N. Author") OR le(dob, "2001-01-01"))) {
        name : name
      }
    }


-
  name: "Filter with implied and as well as 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, reputation: { gt: 2.5 }, or: { dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(((eq(name, "A. N. Author") AND gt(reputation, 2.5)) OR le(dob, "2001-01-01"))) {
        name : name
      }
    }

-
  name: "Filter with implied and nested in 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { reputation: { gt: 2.5 }, dob: { le: "2001-01-01" } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(name, "A. N. Author") OR (le(dob, "2001-01-01") AND gt(reputation, 2.5)))) {
        name : name
      }
    }

-
  name: "Filter nested 'or'"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, or: { reputation: { gt: 2.5 }, or: { dob: { le: "2001-01-01" } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((eq(name, "A. N. Author") OR (gt(reputation, 2.5) OR le(dob, "2001-01-01")))) {
        name : name
      }
    }

-
  name: "Filter with 'not"
  gqlquery: |
    query {
      queryAuthor(filter: { not: { reputation: { gt: 2.5 } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(NOT (gt(reputation, 2.5))) {
        name : name
      }
    }

-
  name: "Filter with first"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, first: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), first: 10) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "Filter with first and offset"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, first: 10, offset: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), first: 10, offset: 10) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "Filter with order asc"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { asc: reputation }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderasc: reputation) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "Filter with order desc"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: reputation) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }


-
  name: "Filter with nested order"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation, then: { asc: dob } }) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: reputation, orderasc: dob) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "Filter with order, first and offset"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } }, order: { desc: reputation }, first: 10, offset: 10) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author), orderdesc: reputation, first: 10, offset: 10) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "Deep filter"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
        posts : posts @filter(anyofterms(title, "GraphQL")) {
          title : title
        }
      }
    }


-
  name: "Deep filter with first"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }, first: 10) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
        posts : posts @filter(anyofterms(title, "GraphQL")) (first: 10) {
          title : title
        }
      }
    }

-
  name: "Deep filter with order, first and offset"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" } }, order: { asc: numLikes }, first: 10, offset: 10) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
        posts : posts @filter(anyofterms(title, "GraphQL")) (orderasc: numLikes, first: 10, offset: 10) {
          title : title
        }
      }
    }


-
  name: "All Float filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { reputation: { gt: 1.1 }, or: { reputation: { ge: 1.1 }, or: { reputation: { lt: 1.1 }, or: { reputation: { le: 1.1 }, or: { reputation: { eq: 1.1 } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((gt(reputation, 1.1) OR (ge(reputation, 1.1) OR (lt(reputation, 1.1) OR (le(reputation, 1.1) OR eq(reputation, 1.1)))))) {
        name : name
      }
    }

-
  name: "All DateTime filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { dob: { gt: "2000-01-01" }, or: { dob: { ge: "2000-01-01" }, or: { dob: { lt: "2000-01-01" }, or: { dob: { le: "2000-01-01" }, or: { dob: { eq: "2000-01-01" } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((gt(dob, "2000-01-01") OR (ge(dob, "2000-01-01") OR (lt(dob, "2000-01-01") OR (le(dob, "2000-01-01") OR eq(dob, "2000-01-01")))))) {
        name : name
      }
    }

-
  name: "All Int filters work"
  gqlquery: |
    query {
      queryPost(filter: { numLikes: { gt: 10 }, or: { numLikes: { ge: 10 }, or: { numLikes: { lt: 10 }, or: { numLikes: { le: 10 }, or: { numLikes: { eq: 10 } } } } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((gt(numLikes, 10) OR (ge(numLikes, 10) OR (lt(numLikes, 10) OR (le(numLikes, 10) OR eq(numLikes, 10)))))) {
        title : title
      }
    }

-
  name: "All String hash filters work"
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(eq(name, "A. N. Author")) {
        name : name
      }
    }

-
  name: "All String exact filters work"
  gqlquery: |
    query {
      queryCountry(filter: { name: { gt: "AAA" }, or: { name: { ge: "AAA" }, or: { name: { lt: "AAA" }, or: { name: { le: "AAA" }, or: { name: { eq: "AAA" } } } } } } ) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter((gt(name, "AAA") OR (ge(name, "AAA") OR (lt(name, "AAA") OR (le(name, "AAA") OR eq(name, "AAA")))))) {
        name : name
      }
    }

-
  name: "All String term filters work"
  gqlquery: |
    query {
      queryPost(filter: { title: { anyofterms: "GraphQL"}, or: { title: { allofterms: "GraphQL" } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((anyofterms(title, "GraphQL") OR allofterms(title, "GraphQL"))) {
        title : title
      }
    }


-
  name: "All String fulltext filters work"
  gqlquery: |
    query {
      queryPost(filter: { text: { anyoftext: "GraphQL"}, or: { text: { alloftext: "GraphQL" } } } ) {
        title
      }
    }
  dgquery: |-
    query {
      queryPost(func: type(Post)) @filter((anyoftext(text, "GraphQL") OR alloftext(text, "GraphQL"))) {
        title : title
      }
    }

-
  name: "All String regexp filters work"
  gqlquery: |
    query {
      queryCountry(filter: { name: { regexp: "/.*ust.*/" }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryCountry(func: type(Country)) @filter(regexp(name, /.*ust.*/)) {
        name : name
      }
    }

-
  name: "Skip directive"
  variables:
    skipTrue: true
    skipFalse: false
  gqlquery: |
    query ($skipTrue: Boolean!, $skipFalse: Boolean!) {
      getAuthor(id: "0x1") {
        name @skip(if: $skipFalse)
        posts @skip(if: $skipTrue) {
          title
          text
        }
      }
    }
  dgquery: |-
    query {
      getAuthor(func: uid(0x1)) @filter(type(Author)) {
        name : name
      }
    }

-
  name: "Include directive"
  variables:
    includeTrue: true
    includeFalse: false
  gqlquery: |
    query ($includeTrue: Boolean!, $includeFalse: Boolean!) {
      queryAuthor {
        name @include(if: $includeTrue)
        posts(filter: { title: { anyofterms: "GraphQL" } }) @include(if: $includeFalse) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
      }
    }

-
  name: "Include only fields for which skip is !false or include is true"
  variables:
    includeFalse: false
    includeTrue: true
    skipFalse: false
    skipTrue: true
  gqlquery: |
    query ($includeFalse: Boolean!, $skipTrue: Boolean!, $includeTrue: Boolean!,
      $skipFalse: Boolean!) {
      queryAuthor {
        dob @include(if: $includeFalse) @skip(if: $skipFalse)
        reputation @include(if: $includeFalse) @skip(if: $skipTrue)
        name @include(if: $includeTrue) @skip(if: $skipFalse)
        posts(filter: { title: { anyofterms: "GraphQL" } }, first: 10) @include(if: $includeTrue)
          @skip(if: $skipTrue) {
          title
          tags
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
      }
    }

-
  name: "getHuman which implements an interface"
  gqlquery: |
    query {
      getHuman(id: "0x1") {
        id
        name
        ename
        dob
        female
      }
    }
  dgquery: |-
    query {
      getHuman(func: uid(0x1)) @filter(type(Human)) {
        id : uid
        name : name
        ename : ename
        dob : dob
        female : female
      }
    }

-
  name: "queryHuman which implements an interface"
  gqlquery: |
    query {
      queryHuman {
        id
        name
        ename
        dob
        female
      }
    }
  dgquery: |-
    query {
      queryHuman(func: type(Human)) {
        id : uid
        name : name
        ename : ename
        dob : dob
        female : female
      }
    }

-
  name: "filter with order for type which implements an interface"
  gqlquery: |
    query {
      queryHuman (filter: { name: { anyofterms: "GraphQL" } }, order: { asc: ename }) {
        id
        name
        ename
        dob
      }
    }
  dgquery: |-
    query {
      queryHuman(func: type(Human), orderasc: ename) @filter(anyofterms(name, "GraphQL")) {
        id : uid
        name : name
        ename : ename
        dob : dob
      }
    }

-
  name: "queryCharacter with fragment for human"
  gqlquery: |
    query {
      queryCharacter {
        id
        name
        ... on Human {
          female
          ename
        }
      }
    }
  dgquery: |-
    query {
      queryCharacter(func: type(Character)) {
        dgraph.type
        id : uid
        name : name
        female : female
        ename : ename
      }
    }

-
  name: "queryCharacter with fragment on multiple types"
  gqlquery: |
    query {
      queryCharacter {
        id
        name
        ... on Human {
          female
          ename
        }
        ... on Director {
          movies
        }
      }
    }
  dgquery: |-
    query {
      queryCharacter(func: type(Character)) {
        dgraph.type
        id : uid
        name : name
        female : female
        ename : ename
        movies : movies
      }
    }

-
  name: "Filter with ids uses uid func at root."
  gqlquery: |
    query {
      queryAuthor(filter: { ids: ["0x1", "0x2"], and: { name: { eq: "A. N. Author" } }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid(0x1, 0x2)) @filter((eq(name, "A. N. Author") AND type(Author))) {
        name : name
      }
    }

-
  name: "Filter with ids inside and argument doesn't use uid func at root."
  gqlquery: |
    query {
      queryAuthor(filter: { name: { eq: "A. N. Author" }, and: { ids: ["0x1", "0x2"] }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter((uid(0x1, 0x2) AND eq(name, "A. N. Author"))) {
        name : name
      }
    }

-
  name: "Filter with ids and not translates correctly.."
  gqlquery: |
    query {
      queryAuthor(filter: { not: { ids: ["0x1", "0x2"] }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) @filter(NOT (uid(0x1, 0x2))) {
        name : name
      }
    }

-
  name: "Deep filter with ids"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { ids: ["0x1", "0x2"], and: { title: { anyofterms: "GraphQL" } }}) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
        posts : posts @filter((anyofterms(title, "GraphQL") AND uid(0x1, 0x2))) {
          title : title
        }
      }
    }

-
  name: "Deep filter with ids in not key"
  gqlquery: |
    query {
      queryAuthor {
        name
        posts(filter: { title: { anyofterms: "GraphQL" }, not: { ids: ["0x1", "0x2"] } }) {
          title
        }
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: type(Author)) {
        name : name
        posts : posts @filter((NOT (uid(0x1, 0x2)) AND anyofterms(title, "GraphQL"))) {
          title : title
        }
      }
    }

-
  name: "Filter with no valid ids construct the right query with type func at root."
  gqlquery: |
    query {
      queryAuthor(filter: { ids: ["alice", "bob"], and: { name: { eq: "A. N. Author" } }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid()) @filter((eq(name, "A. N. Author") AND type(Author))) {
        name : name
      }
    }

-
  name: "Filter with ids only includes valid ids in dgquery."
  gqlquery: |
    query {
      queryAuthor(filter: { ids: ["0x1", "bob"], and: { name: { eq: "A. N. Author" } }}) {
        name
      }
    }
  dgquery: |-
    query {
      queryAuthor(func: uid(0x1)) @filter((eq(name, "A. N. Author") AND type(Author))) {
        name : name
      }
    }