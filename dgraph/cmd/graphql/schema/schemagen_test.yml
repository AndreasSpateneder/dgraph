schemas:
  -
    name: "Object data type"
    input: |
      type A {
        id: ID!
        p: P
      }
      type P {
        id: ID!
      }
    output: |
      type A {
        p: uid
      }
      type P {
      }
      p: uid .

  -
    name: "Scalar list"
    input: |
      type X {
        id: ID!
        names: [String!]
      }
    output: |
      type X {
        names: [string]
      }
      names: [string] .

  -
    name: "Object list"
    input: |
      type X {
        p: [P!]!
      }
      type P {
        id: ID!
      }
    output: |
      type X {
        p: [uid]
      }
      type P {
      }
      p: [uid] .

  -
    name: "Scalar types"
    input: |
      type X {
        p: Int
        pList: [Int]
        q: Boolean
        r: String
        rList: [String]
        s: DateTime
        sList: [DateTime]
        t: Float
        tList: [Float]
        u: ID
      }
    output: |
      type X {
        p: int
        pList: [int]
        q: bool
        r: string
        rList: [string]
        s: dateTime
        sList: [dateTime]
        t: float
        tList: [float]
      }
      p: int .
      pList: [int] .
      q: bool .
      r: string .
      rList: [string] .
      s: dateTime .
      sList: [dateTime] .
      t: float .
      tList: [float] .

  -
    name: "enum - always gets an index"
    input: |
      type X {
        e: E
        f: [E]
      }
      enum E { A }
    output: |
      type X {
        e: string
        f: [string]
      }
      e: string @index(exact) .
      f: [string] @index(exact) .


  -
    name: "Search indexes are correct"
    input: |
      type X {
        i1: Int @search
        i2: Int @search(by: int)
        f1: Float @search
        f2: Float @search(by: float)
        b1: Boolean @search
        b2: Boolean @search(by: bool)
        s1: String @search
        s2: String @search(by: hash)
        s3: String @search(by: exact)
        s4: String @search(by: term)
        s5: String @search(by: fulltext)
        s6: String @search(by: trigram)
        s7: String @search(by: regexp)
        dt1: DateTime @search
        dt2: DateTime @search(by: year)
        dt3: DateTime @search(by: month)
        dt4: DateTime @search(by: day)
        dt5: DateTime @search(by: hour)
        e: E @search
      }
      enum E { A }
    output: |
      type X {
        i1: int
        i2: int
        f1: float
        f2: float
        b1: bool
        b2: bool
        s1: string
        s2: string
        s3: string
        s4: string
        s5: string
        s6: string
        s7: string
        dt1: dateTime
        dt2: dateTime
        dt3: dateTime
        dt4: dateTime
        dt5: dateTime
        e: string
      }
      b1: bool @index(bool) .
      b2: bool @index(bool) .
      dt1: dateTime @index(year) .
      dt2: dateTime @index(year) .
      dt3: dateTime @index(month) .
      dt4: dateTime @index(day) .
      dt5: dateTime @index(hour) .
      e: string @index(exact) .
      f1: float @index(float) .
      f2: float @index(float) .
      i1: int @index(int) .
      i2: int @index(int) .
      s1: string @index(term) .
      s2: string @index(hash) .
      s3: string @index(exact) .
      s4: string @index(term) .
      s5: string @index(fulltext) .
      s6: string @index(trigram) .
      s7: string @index(trigram) .

  -
    name: "interface and types interact properly"
    input: |
      interface A {
        id: ID!
        name: String! @search(by: exact)
      }
      type B implements A {
        correct: Boolean @search
      }
      type C implements A {
        dob: DateTime!
      }
    output: |
      type A {
        name: string
      }
      type B {
        name: string
        correct: bool
      }
      type C {
        name: string
        dob: dateTime
      }
      correct: bool @index(bool) .
      dob: dateTime .
      name: string @index(exact) .

  -
    name: "Searchables are collected across all types."
    input: |
      type A {
        id: ID!
        p: String! @search(by: exact)
        friend: P
      }
      type P {
        id: ID!
        p: String! @search(by: term)
      }
      type B {
        id: ID!
        p: String! @search(by: fulltext)
        friend: P
      }
      type C {
        id: ID!
        p: String! @search(by: exact)
        friend: P
      }
    output: |
      type A {
        p: string
        friend: uid
      }
      type P {
        p: string
      }
      type B {
        p: string
        friend: uid
      }
      type C {
        p: string
        friend: uid
      }
      friend: uid .
      p: string @index(exact,fulltext,term) .

